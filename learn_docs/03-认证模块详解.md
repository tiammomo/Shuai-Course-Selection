# 认证模块详解

## 1. 认证架构概览

选课系统采用 **Session + Redis** 的认证方案，支持三种用户角色的细粒度权限控制。

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           认证架构图                                      │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────┐     ┌─────────────┐     ┌─────────────────────────────┐
│   Client    │────►│  Gin Server │────►│      Auth Middleware        │
│  (Browser)  │     │   (API)     │     │     (认证 + 权限验证)        │
└─────────────┘     └─────────────┘     └─────────────────────────────┘
        │                  │                        │
        │  Cookie          │                        │
        │  camp-session    │                        │
        └──────────────────┘                        │
                                                   │
                                                   ▼
                                          ┌─────────────────────┐
                                          │      Redis          │
                                          │  Session 存储       │
                                          │  Key: session:{id}  │
                                          └─────────────────────┘
```

---

## 2. Session 管理

### 2.1 Session 数据结构

**Redis 存储格式**:
```
Key: session:{uuid}
TTL: 3600 秒 (1小时)
Value: JSON
```

**示例值**:
```json
{
  "user_id": "1",
  "username": "admin",
  "nickname": "管理员",
  "user_type": 1
}
```

### 2.2 Cookie 配置

| 配置项 | 值 | 说明 |
|--------|-----|------|
| Cookie Name | `camp-session` | Session ID 存储的 Cookie 名称 |
| Cookie MaxAge | 3600 | Cookie 存活时间 (秒) |
| Cookie HttpOnly | true | 防止 XSS 攻击 |
| Cookie Secure | false | 开发环境设为 false |

### 2.3 Session 生命周期

```
登录流程:
  1. 用户提交用户名密码
  2. 服务端验证通过
  3. 生成 UUID 作为 sessionId
  4. 将用户信息写入 Redis
  5. 设置 Cookie (sessionId)
  6. 返回登录成功

登出流程:
  1. 从 Cookie 获取 sessionId
  2. 删除 Redis 中的 Session
  3. 设置 Cookie 过期 (maxAge=-1)

续期策略:
  - Session TTL 固定 1 小时
  - 登录时重新生成 sessionId (防止 Session 固定攻击)
```

---

## 3. 中间件设计

### 3.1 AuthMiddleware 结构

```go
type AuthMiddleware struct {
    redis      *redis.Client
    sessionKey string
    cookieName string
}
```

### 3.2 核心中间件方法

#### RequireAuth - 需要登录

```go
func (m *AuthMiddleware) RequireAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 从 Cookie 获取 sessionId
        sessionId, err := c.Cookie(m.cookieName)
        if err != nil {
            c.JSON(200, response.Unauthorized("用户未登录"))
            c.Abort()
            return
        }

        // 2. 从 Redis 获取 Session 数据
        session := sessions.Default(c)
        v := session.Get(m.sessionKey)  // sessionKey = "session_data"
        if v == nil {
            c.JSON(200, response.Unauthorized("登录已过期"))
            c.Abort()
            return
        }

        // 3. 类型断言并设置到 Context
        data, ok := v.(map[string]interface{})
        if !ok {
            c.JSON(200, response.Unauthorized("无效的会话"))
            c.Abort()
            return
        }

        c.Set("session_data", data)
        c.Next()
    }
}
```

#### RequireAdmin - 需要管理员权限

```go
func (m *AuthMiddleware) RequireAdmin() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 先经过 RequireAuth
        m.RequireAuth()(c)
        if c.IsAborted() {
            return
        }

        // 检查 user_type == 1
        data, _ := c.Get("session_data")
        sessionData := data.(map[string]interface{})
        userType := sessionData["user_type"].(int)

        if userType != 1 {
            c.JSON(200, response.Forbidden("需要管理员权限"))
            c.Abort()
            return
        }

        c.Next()
    }
}
```

### 3.3 路由权限配置

```go
// 公开路由 (无需登录)
publicRoutes := router.Group("/auth")
publicRoutes.POST("/login", authHandler.Login)
publicRoutes.POST("/logout", authHandler.Logout)
publicRoutes.GET("/whoami", authHandler.WhoAmI)

// 教师路由 (需要教师或管理员权限)
teacherRoutes := router.Group("/teacher")
teacherRoutes.Use(authMiddleware.RequireAuth())
teacherRoutes.GET("/course", courseHandler.GetTeacherCourses)

// 学生路由 (需要学生权限)
studentRoutes := router.Group("/student")
studentRoutes.Use(authMiddleware.RequireAuth())
studentRoutes.POST("/book", selectionAppService.BookCourse)

// 管理员路由 (需要管理员权限)
adminRoutes := router.Group("/admin")
adminRoutes.Use(authMiddleware.RequireAdmin())
adminRoutes.GET("/users", adminHandler.ListUsers)
```

---

## 4. 密码安全

### 4.1 密码加密

系统使用 **bcrypt** 算法加密密码，Cost = 10：

```go
// 加密密码
func Encrypt(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    return string(bytes), err
}

// 验证密码
func CheckPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}
```

### 4.2 密码安全特性

| 特性 | 说明 |
|------|------|
| 加盐 | bcrypt 自动加盐，防止彩虹表攻击 |
| 慢哈希 | bcrypt 计算耗时，抵抗暴力破解 |
| 成本因子 | 使用 DefaultCost (10)，可调整 |

---

## 5. API 接口详解

### 5.1 POST /auth/login - 用户登录

**请求**:
```json
{
  "username": "admin",
  "password": "AdminPass123"
}
```

**成功响应**:
```json
{
  "code": 0,
  "data": {
    "user_id": "1"
  }
}
```

**失败响应**:
```json
{
  "code": 10001,
  "msg": "用户名或密码错误"
}
```

**处理流程**:
```
1. 参数绑定与校验
2. 根据 username 查询用户 (MemberRepo)
3. bcrypt 验证密码
4. 生成 sessionId (UUID)
5. 写入 Redis Session
6. 设置 Cookie
7. 返回 user_id
```

### 5.2 POST /auth/logout - 用户登出

**请求**: 无需参数，自动从 Cookie 获取 sessionId

**成功响应**:
```json
{
  "code": 0,
  "msg": "登出成功"
}
```

**处理流程**:
```
1. 从 Cookie 获取 sessionId
2. 删除 Redis 中的 Session
3. 设置 Cookie 过期
```

### 5.3 GET /auth/whoami - 获取当前用户信息

**成功响应**:
```json
{
  "code": 0,
  "data": {
    "user_id": "1",
    "username": "admin",
    "nickname": "管理员",
    "user_type": 1
  }
}
```

---

## 6. 错误码定义

| 错误码 | 说明 |
|--------|------|
| 10000 | 成功 |
| 10001 | 用户名或密码错误 |
| 10002 | 用户不存在 |
| 10003 | 用户已禁用 |
| 10004 | 登录已过期 |
| 10005 | 需要管理员权限 |
| 10006 | 需要学生权限 |

---

## 7. 安全增强建议

### 7.1 当前安全措施

| 措施 | 实现 |
|------|------|
| HttpOnly Cookie | 防止 XSS 攻击读取 Cookie |
| Session 过期 | Redis TTL 3600 秒 |
| bcrypt 加密 | 密码安全存储 |

### 7.2 可选增强

| 安全措施 | 说明 |
|----------|------|
| HTTPS | 生产环境强制使用 HTTPS |
| CSRF Token | 防止跨站请求伪造 |
| 登录限流 | 5次/分钟，防止暴力破解 |
| 密码强度要求 | 最少 8 位，包含大小写字母和数字 |
| Session 绑定 IP | 限制 Session 只能从同一 IP 使用 |

---

## 8. 核心代码文件

| 文件 | 路径 | 说明 |
|------|------|------|
| `auth.go` | `internal/interface/api/middleware/auth.go` | 中间件实现 |
| `auth_handler.go` | `internal/interface/api/handler/auth_handler.go` | 处理器 |
| `auth_service.go` | `internal/domain/service/auth_service.go` | 认证服务 |
| `password.go` | `internal/infrastructure/encrypt/password.go` | 密码加密 |
| `router.go` | `internal/interface/api/router/router.go` | 路由配置 |
