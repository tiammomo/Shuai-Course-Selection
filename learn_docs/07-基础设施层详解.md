# 基础设施层详解

## 1. 概述

基础设施层负责与外部系统（数据库、缓存、消息队列等）的集成，为上层提供技术支持。

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        基础设施层位置                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Interface Layer  ──►  Application Layer  ──►  Domain Layer            │
│                                                                         │
│                                     ▲                                   │
│                                     │ 依赖                               │
│                         ┌───────────┴───────────┐                       │
│                         │   Infrastructure Layer │                      │
│                         └───────────────────────┘                       │
│                         │                         │                     │
│                         ▼                         ▼                     │
│                   ┌──────────┐             ┌──────────┐                │
│                   │ Database │             │  Redis   │                │
│                   └──────────┘             └──────────┘                │
│                         │                         │                     │
│                         ▼                         ▼                     │
│                   ┌──────────┐             ┌──────────┐                │
│                   │   MQ     │             │ Encrypt  │                │
│                   └──────────┘             └──────────┘                │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 数据库层

### 2.1 MySQL + GORM 配置

**初始化代码** ([mysql.go](internal/infrastructure/database/mysql.go)):

```go
func Init(cfg *config.DatabaseConfig) error {
    db, err := gorm.Open(mysql.Open(cfg.DSN()), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
        NamingStrategy: schema.NamingStrategy{
            TablePrefix:   "",
            SingularTable: true,  // 使用单数表名
        },
    })
    if err != nil {
        return fmt.Errorf("failed to connect database: %w", err)
    }

    sqlDB, err := db.DB()
    sqlDB.SetMaxIdleConns(cfg.MaxIdleConns)      // 空闲连接池
    sqlDB.SetMaxOpenConns(cfg.MaxOpenConns)      // 最大连接数

    // 自动迁移
    if err := migrate(db); err != nil {
        return fmt.Errorf("failed to migrate: %w", err)
    }

    return nil
}
```

### 2.2 连接池配置

```yaml
database:
  max_idle_conns: 10    # 空闲连接数
  max_open_conns: 100   # 最大连接数
```

| 配置项 | 值 | 说明 |
|--------|-----|------|
| MaxIdleConns | 10 | 空闲连接池大小 |
| MaxOpenConns | 100 | 最大打开的连接数 |
| ConnMaxLifetime | 无 | 连接最长存活时间 (默认永久) |

### 2.3 自动迁移

```go
func migrate(db *gorm.DB) error {
    return db.AutoMigrate(
        &model.Member{},
        &model.Course{},
        &model.Bind{},
        &model.Choice{},
    )
}
```

### 2.4 仓储实现示例

**CourseRepoImpl** ([course_repo_impl.go](internal/infrastructure/database/course_repo_impl.go)):

```go
type CourseRepoImpl struct {
    db *gorm.DB
}

func (r *CourseRepoImpl) Create(ctx context.Context, course *model.Course) error {
    return r.db.WithContext(ctx).Create(course).Error
}

func (r *CourseRepoImpl) GetByID(ctx context.Context, id int) (*model.Course, error) {
    var course model.Course
    err := r.db.WithContext(ctx).First(&course, id).Error
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, nil
        }
        return nil, err
    }
    return &course, nil
}

func (r *CourseRepoImpl) Update(ctx context.Context, id int, updates map[string]interface{}) error {
    return r.db.WithContext(ctx).Model(&model.Course{}).
        Where("course_id = ?", id).
        Updates(updates).Error
}
```

---

## 3. Redis 层

### 3.1 连接池配置

**初始化代码** ([redis.go](internal/infrastructure/redis/redis.go)):

```go
func New(cfg *config.RedisConfig) (*Client, error) {
    pool := &redis.Pool{
        MaxActive:   cfg.PoolSize,
        MaxIdle:     cfg.PoolSize,
        IdleTimeout: time.Minute * 5,
        Dial: func() (redis.Conn, error) {
            c, err := redis.Dial("tcp", cfg.Addr(),
                redis.DialPassword(cfg.Password),
                redis.DialDatabase(cfg.DB),
                redis.DialConnectTimeout(cfg.DialTimeout),
                redis.DialReadTimeout(cfg.ReadTimeout),
                redis.DialWriteTimeout(cfg.WriteTimeout),
            )
            if err != nil {
                return nil, fmt.Errorf("failed to connect redis: %w", err)
            }
            return c, nil
        },
    }

    // 测试连接
    conn := pool.Get()
    defer conn.Close()
    if _, err := conn.Do("PING"); err != nil {
        return nil, fmt.Errorf("failed to ping redis: %w", err)
    }

    return &Client{pool: pool}, nil
}
```

### 3.2 配置参数

```yaml
redis:
  host: "localhost"
  port: 6379
  password: "${REDIS_PASSWORD}"
  db: 0
  pool_size: 100
  dial_timeout: 5s
  read_timeout: 3s
  write_timeout: 3s
```

| 配置项 | 说明 |
|--------|------|
| PoolSize | 连接池大小 |
| IdleTimeout | 空闲连接超时 |
| DialTimeout | 连接超时 |
| ReadTimeout | 读取超时 |
| WriteTimeout | 写入超时 |

### 3.3 核心操作方法

```go
// Hash 原子递增
func (c *Client) HIncrBy(ctx context.Context, key string, field string, delta int) (int, error)

// Set 判断成员是否存在
func (c *Client) SIsMember(ctx context.Context, key string, member interface{}) (bool, error)

// Set 获取所有成员
func (c *Client) SMembers(ctx context.Context, key string) ([]string, error)

// List 左推入
func (c *Client) LPush(ctx context.Context, key string, values ...interface{}) (int, error)
```

---

## 4. 消息队列层

### 4.1 RocketMQ 配置

```yaml
rocketmq:
  nameserver: "localhost:9876"
  group_id: "course-select-group"
  topic: "course-booking-topic"
  instance_name: "course-selection-instance"
```

### 4.2 消息结构

```go
type BookingMessage struct {
    StudentID string    `json:"student_id"`
    CourseID  string    `json:"course_id"`
    Timestamp time.Time `json:"timestamp"`
}
```

### 4.3 消费者处理

```go
func StartConsumer(choiceRepo repository.IChoiceRepo, redis *redis.Client) {
    for {
        // 从 Redis 队列获取消息
        data, err := redis.BRPop(ctx, "booking:queue", 0)
        if err != nil {
            continue
        }

        // 解析消息
        var msg BookingMessage
        json.Unmarshal([]byte(data[1]), &msg)

        // 写入数据库
        choice := &model.Choice{
            StudentID: msg.StudentID,
            CourseID:  msg.CourseID,
        }
        choiceRepo.Create(ctx, choice)

        // 更新学生已选课程 Set
        redis.SAdd(ctx, fmt.Sprintf("student:%s:courses", msg.StudentID), msg.CourseID)
    }
}
```

---

## 5. 加密工具

### 5.1 密码加密 (bcrypt)

**实现** ([password.go](internal/infrastructure/encrypt/password.go)):

```go
package encrypt

import "golang.org/x/crypto/bcrypt"

// Encrypt 加密密码
func Encrypt(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    return string(bytes), err
}

// CheckPassword 验证密码
func CheckPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}
```

### 5.2 bcrypt 特性

| 特性 | 说明 |
|------|------|
| 加盐 | 自动生成随机盐值 |
| 成本因子 | 默认 10，可调整 |
| 慢哈希 | 抵抗暴力破解 |

---

## 6. 配置管理

### 6.1 Viper 配置读取

```go
import "github.com/spf13/viper"

func LoadConfig(path string) (*config.Config, error) {
    viper.SetConfigFile(path)
    viper.SetConfigType("yaml")

    // 环境变量支持
    viper.AutomaticEnv()

    if err := viper.ReadInConfig(); err != nil {
        return nil, err
    }

    var cfg config.Config
    if err := viper.Unmarshal(&cfg); err != nil {
        return nil, err
    }

    return &cfg, nil
}
```

### 6.2 环境变量支持

```yaml
database:
  password: "${DB_PASSWORD}"  # 自动读取环境变量

redis:
  password: "${REDIS_PASSWORD}"
```

---

## 7. 基础设施文件清单

| 文件 | 路径 | 说明 |
|------|------|------|
| `mysql.go` | `internal/infrastructure/database/mysql.go` | MySQL 初始化与连接池 |
| `course_repo_impl.go` | `internal/infrastructure/database/course_repo_impl.go` | 课程仓储实现 |
| `member_repo_impl.go` | `internal/infrastructure/database/member_repo_impl.go` | 成员仓储实现 |
| `redis.go` | `internal/infrastructure/redis/redis.go` | Redis 客户端封装 |
| `password.go` | `internal/infrastructure/encrypt/password.go` | bcrypt 密码加密 |

---

## 8. 学习要点

### 8.1 GORM 关键操作

| 操作 | 方法 | 说明 |
|------|------|------|
| 创建 | `db.Create()` | 插入新记录 |
| 查询 | `db.First()` | 按主键查询 |
| 查询 | `db.Where()` | 条件查询 |
| 更新 | `db.Updates()` | 更新指定字段 |
| 删除 | `db.Delete()` | 软删除 |

### 8.2 Redis 关键操作

| 操作 | 命令 | 说明 |
|------|------|------|
| Hash | `HINCRBY` | 原子递增，用于容量扣减 |
| Set | `SISMEMBER` | 判断成员是否存在 |
| Set | `SADD` | 添加集合成员 |
| List | `LPUSH` | 左推入队列 |

### 8.3 连接池最佳实践

| 场景 | 配置建议 |
|------|----------|
| Web 应用 | MySQL MaxOpenConns = CPU数 * 2 + 1 |
| 高并发 | Redis PoolSize = 100 |
| 空闲超时 | Redis IdleTimeout = 5分钟 |
