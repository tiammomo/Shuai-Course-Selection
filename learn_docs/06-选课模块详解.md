# 选课模块详解

## 1. 模块概述

选课模块是系统的核心高并发模块，负责处理学生选课和退课操作。该模块采用 **Redis + 消息队列** 的架构来处理高并发场景下的课程选择。

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           选课模块架构                                    │
└─────────────────────────────────────────────────────────────────────────┘

    ┌──────────┐     ┌──────────────────┐     ┌──────────────────┐
    │  Client  │────►│  API Handler     │────►│ 限流 (rate.Limit)│
    └──────────┘     └──────────────────┘     └──────────────────┘
                                                   │
                                                   ▼
    ┌──────────┐     ┌──────────────────┐     ┌──────────────────┐
    │  Client  │◄────│   JSON Response  │◄────│ Redis 原子操作   │
    └──────────┘     └──────────────────┘     │ HINCRBY         │
                                              └──────────────────┘
                                                   │
                                                   ▼
                                              ┌──────────────────┐
                                              │  消息队列 (MQ)   │
                                              │ 异步写入数据库   │
                                              └──────────────────┘
```

---

## 2. 高并发处理策略

### 2.1 核心挑战

选课系统在选课高峰期面临以下挑战：

| 挑战 | 描述 |
|------|------|
| 超卖问题 | 多个学生同时选择同一门课程，可能超过容量 |
| 数据库压力 | 大量并发写入可能导致数据库崩溃 |
| 响应延迟 | 数据库操作耗时影响用户体验 |

### 2.2 解决方案

| 策略 | 实现方式 | 作用 |
|------|----------|------|
| 限流 | golang.org/x/time/rate | 控制请求速率，防止系统过载 |
| 缓存 | Redis Hash 存储剩余容量 | 快速判断容量，原子操作 |
| 异步写入 | RocketMQ 消息队列 | 削峰填谷，异步持久化 |
| 预检查 | Redis Set 检查重复选课 | 快速过滤重复请求 |

---

## 3. Redis 数据结构

### 3.1 课程剩余容量 (Hash)

```
Key: course:capacity
Field: course_id
Value: remaining_count (剩余可选数量)
```

**示例操作**:
```bash
# 初始化课程容量
HSET course:capacity 1 100 2 50 3 60

# 选课时原子递减
HINCRBY course:capacity 1 -1

# 如果返回 < 0，表示已满，回滚
HINCRBY course:capacity 1 1
```

### 3.2 学生已选课程 (Set)

```
Key: student:{student_id}:courses
Value: course_id (课程ID集合)
```

**示例操作**:
```bash
# 检查学生是否已选该课程
SISMEMBER student:4:courses 1

# 添加已选课程
SADD student:4:courses 1 2

# 获取学生所有已选课程
SMEMBERS student:4:courses
```

### 3.3 选课请求队列 (List)

```
Key: booking:queue
Value: BookingMessage JSON
```

**示例操作**:
```bash
# 写入选课请求
LPUSH booking:queue {"student_id":"4","course_id":"1","timestamp":"..."}
```

---

## 4. 选课流程详解

### 4.1 时序图

```
学生                    Handler              SelectionApp       Redis              DB
 │                        │                      │                │                 │
 │ POST /book_course      │                      │                │                 │
 │ {student_id, course_id}│                      │                │                 │
 │───────────────────────>│                      │                │                 │
 │                        │ 1. 限流检查          │                │                 │
 │                        │─────────────────────>│                │                 │
 │                        │                      │                │                 │
 │                        │ 2. 检查重复选课      │                │                 │
 │                        │─────────────────────>│                │                 │
 │                        │                      │ SISMEMBER      │                 │
 │                        │                      │───────────────>│                 │
 │                        │                      │                │                 │
 │                        │ 3. 检查课程存在      │                │                 │
 │                        │─────────────────────>│                │                 │
 │                        │                      │ GetByID        │                 │
 │                        │                      │────────────────│────────────────>│
 │                        │                      │                │                 │
 │                        │ 4. Redis 原子扣减    │                │                 │
 │                        │                      │ HINCRBY -1     │                 │
 │                        │                      │───────────────>│                 │
 │                        │                      │                │                 │
 │                        │ 5. 判断容量          │                │                 │
 │                        │◄─────────────────────│                │                 │
 │                        │  (remaining < 0?)    │                │                 │
 │                        │                      │                │                 │
 │                        │ 6. 容量不足回滚      │                │                 │
 │                        │                      │ HINCRBY +1     │                 │
 │                        │                      │───────────────>│                 │
 │                        │◄─────────────────────│                │                 │
 │                        │                      │                │                 │
 │                        │ 7. 写入 MQ 队列      │                │                 │
 │                        │                      │ LPUSH          │                 │
 │                        │                      │───────────────>│                 │
 │                        │                      │                │                 │
 │                        │ 8. 返回成功          │                │                 │
 │<───────────────────────│                      │                │                 │
 │   {code: 0}            │                      │                │                 │
```

### 4.2 核心代码实现

```go
func (s *SelectionAppService) BookCourse(ctx context.Context, req *dto.BookCourseRequest) error {
    // 1. 限流检查
    if err := s.limiter.Wait(ctx); err != nil {
        return errcode.UnknownError.WithMsg("请求过于频繁")
    }

    // 2. 解析 ID
    studentID, _ := strconv.Atoi(req.StudentID)
    courseID, _ := strconv.Atoi(req.CourseID)

    // 3. 检查学生是否已选过该课程 (从 Redis)
    enrolled, err := s.redis.SIsMember(ctx, fmt.Sprintf("student:%d:courses", studentID), req.CourseID)
    if err != nil {
        return err
    }
    if enrolled {
        return errcode.RepeatRequest
    }

    // 4. 检查课程是否存在
    course, err := s.courseRepo.GetByID(ctx, courseID)
    if err != nil {
        return err
    }
    if course == nil {
        return errcode.CourseNotExisted
    }

    // 5. 检查课程容量 (Redis 原子操作)
    remaining, err := s.redis.HIncrBy(ctx, "course:capacity", req.CourseID, -1)
    if err != nil {
        return err
    }
    if remaining < 0 {
        // 回滚
        if _, rollbackErr := s.redis.HIncrBy(ctx, "course:capacity", req.CourseID, 1); rollbackErr != nil {
            return errcode.UnknownError.WithMsg("容量回滚失败")
        }
        return errcode.CourseNotAvailable
    }

    // 6. 发送异步消息到 MQ
    msg := &mq.BookingMessage{
        StudentID: req.StudentID,
        CourseID:  req.CourseID,
        Timestamp: time.Now(),
    }
    body, _ := json.Marshal(msg)

    // 直接写入 Redis 队列
    if _, err := s.redis.LPush(ctx, "booking:queue", string(body)); err != nil {
        // 回滚
        if _, rollbackErr := s.redis.HIncrBy(ctx, "course:capacity", req.CourseID, 1); rollbackErr != nil {
            return errcode.UnknownError.WithMsg("队列写入失败，回滚也失败")
        }
        return err
    }

    return nil
}
```

### 4.3 关键保护点

| 步骤 | 保护措施 | 说明 |
|------|----------|------|
| 限流 | rate.Limiter | 4000 QPS，防止系统过载 |
| 重复检查 | Redis SISMEMBER | 快速判断，避免重复选课 |
| 容量检查 | Redis HINCRBY | 原子操作，防止超卖 |
| 失败回滚 | Redis HINCRBY +1 | 操作失败时恢复容量 |
| 异步持久化 | MQ 队列 | 削峰填谷，降低数据库压力 |

---

## 5. 容量初始化

### 5.1 启动时加载

```go
// 从数据库加载课程容量到 Redis
func InitCourseCapacity(db *gorm.DB, redis *redis.Client) error {
    var courses []model.Course
    db.Find(&courses)

    for _, course := range courses {
        // 计算已选人数
        var count int64
        db.Model(&model.Choice{}).
            Where("course_id = ?", course.CourseID).
            Count(&count)

        remaining := course.Capacity - int(count)

        // 写入 Redis
        redis.HSet("course:capacity", course.CourseID, remaining)
    }
    return nil
}
```

### 5.2 数据一致性

| 场景 | 处理方式 |
|------|----------|
| 启动时 | 从数据库加载容量到 Redis |
| 选课成功后 | Redis 扣减，异步写入数据库 |
| 退课时 | Redis 增加，异步删除数据库记录 |
| 数据库恢复 | 定期同步数据库到 Redis |

---

## 6. 获取学生课表

### 6.1 流程

```
1. 从 Redis 获取学生已选课程 ID 列表
2. 遍历课程 ID，从数据库获取课程详情
3. 返回课程列表
```

### 6.2 代码实现

```go
func (s *SelectionAppService) GetStudentCourses(ctx context.Context, studentID string) ([]dto.CourseDTO, error) {
    id, _ := strconv.Atoi(studentID)

    // 从 Redis 获取学生选课列表
    courseIDs, err := s.redis.SMembers(ctx, fmt.Sprintf("student:%d:courses", id))
    if err != nil {
        return nil, err
    }

    var courses []dto.CourseDTO
    for _, courseID := range courseIDs {
        cID, _ := strconv.Atoi(courseID)
        course, err := s.courseRepo.GetByID(ctx, cID)
        if err != nil || course == nil {
            continue
        }

        courses = append(courses, dto.CourseDTO{
            CourseID:  courseID,
            Name:      course.Name,
            TeacherID: intToStringPtr(course.TeacherID),
        })
    }

    return courses, nil
}
```

---

## 7. API 接口

### 7.1 路由配置

```go
student := v1.Group("/student")
{
    student.POST("/book_course", r.courseHandler.BookCourse)
    student.GET("/course", r.courseHandler.GetStudentCourses)
}
```

### 7.2 接口详情

#### POST /api/v1/student/book_course - 选课

**请求体**:
```json
{
  "student_id": "4",
  "course_id": "1"
}
```

**成功响应**:
```json
{
  "code": 0,
  "msg": "选课成功"
}
```

**失败响应**:
```json
{
  "code": 10007,
  "msg": "课程已满"
}
```

#### GET /api/v1/student/course - 获取课表

**请求参数**:
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| student_id | string | 是 | 学生ID |

**响应示例**:
```json
{
  "code": 0,
  "data": [
    {
      "course_id": "1",
      "name": "高等数学",
      "teacher_id": "2"
    },
    {
      "course_id": "2",
      "name": "大学物理",
      "teacher_id": "3"
    }
  ]
}
```

---

## 8. 错误码

| 错误码 | 说明 |
|--------|------|
| 10000 | 成功 |
| 10007 | 课程已满 |
| 10008 | 重复选课 |
| 10009 | 课程不存在 |

---

## 9. 性能优化建议

### 9.1 当前优化

| 优化点 | 实现 |
|--------|------|
| 限流 | rate.Limiter 4000 QPS |
| 缓存 | Redis Hash 存储容量 |
| 异步 | 消息队列削峰 |

### 9.2 可选优化

| 优化点 | 说明 |
|--------|------|
| 分片锁 | 使用 Redis Lua 脚本进一步保证原子性 |
| 预扣留 | 提前预留容量，支持更复杂的业务场景 |
| 热点课程 | 对热门课程使用单独的 Redis 实例 |
| 批量处理 | 消费者批量写入数据库，减少数据库连接 |

---

## 10. 核心代码文件

| 文件 | 路径 | 说明 |
|------|------|------|
| `selection_app.go` | `internal/application/service/selection_app.go` | 选课应用服务 |
| `redis.go` | `internal/infrastructure/redis/redis.go` | Redis 客户端 |
| `course_handler.go` | `internal/interface/api/handler/course_handler.go` | HTTP 处理器 |

---

## 11. 学习要点

1. **Redis 原子操作**: HINCRBY 保证并发下的容量扣减原子性
2. **限流**: 使用 golang.org/x/time/rate 控制 QPS
3. **消息队列**: RocketMQ 实现异步持久化，削峰填谷
4. **回滚机制**: 操作失败时恢复 Redis 数据
5. **重复检查**: Redis Set 快速判断重复选课
6. **容量初始化**: 启动时从数据库加载容量到 Redis
