# 测试指南

## 1. 测试概述

本项目使用 Go 内置的 `testing` 框架进行单元测试和集成测试。

---

## 2. 测试目录结构

```
test/
├── unit/                    # 单元测试
│   ├── model_test.go       # 模型测试
│   └── scheduling_test.go  # 排课算法测试
└── load/                    # 压力测试
    └── load_test.go        # 负载测试
```

---

## 3. 运行测试

### 3.1 运行所有测试

```bash
# 运行所有测试
go test ./test/... -v

# 运行单元测试
go test ./test/unit/... -v

# 运行负载测试
go test ./test/load/... -v
```

### 3.2 运行指定测试

```bash
# 运行单个测试文件
go test ./test/unit/model_test.go -v

# 运行单个测试函数
go test ./test/unit/... -run TestCreateMemberRequest_Validate -v
```

### 3.3 生成测试覆盖率

```bash
# 生成覆盖率报告
go test ./... -coverprofile=coverage.out

# 查看覆盖率
go tool cover -func=coverage.out

# 生成 HTML 覆盖率报告
go test ./... -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html
```

---

## 4. 单元测试

### 4.1 模型测试 (model_test.go)

#### TestCreateMemberRequest_Validate - 创建成员请求验证

```go
func TestCreateMemberRequest_Validate(t *testing.T) {
    tests := []struct {
        name    string
        req     model.CreateMemberRequest
        wantErr bool
    }{
        {
            name: "有效的请求",
            req: model.CreateMemberRequest{
                Username:  "testuser",
                Password:  "Password1",
                Nickname:  "TestUser",
                UserType:  model.UserTypeStudent,
            },
            wantErr: false,
        },
        {
            name: "无效的用户类型",
            req: model.CreateMemberRequest{
                Username:  "testuser",
                Password:  "Password1",
                Nickname:  "TestUser",
                UserType:  99,
            },
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tt.req.Validate()
            if (err != nil) != tt.wantErr {
                t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}
```

**测试场景**:
| 场景 | 输入 | 期望结果 |
|------|------|----------|
| 有效请求 | 合法的创建请求 | false (无错误) |
| 无效用户类型 | user_type=99 | true (有错误) |
| 管理员类型 | user_type=1 (管理员) | false |
| 教师类型 | user_type=2 (教师) | false |

---

#### TestCreateCourseRequest_Validate - 创建课程请求验证

```go
func TestCreateCourseRequest_Validate(t *testing.T) {
    tests := []struct {
        name    string
        req     model.CreateCourseRequest
        wantErr bool
    }{
        {
            name: "有效的课程请求",
            req: model.CreateCourseRequest{
                Name: "高等数学",
                Cap:  100,
            },
            wantErr: false,
        },
        {
            name: "无效的容量 - 0",
            req: model.CreateCourseRequest{
                Name: "无效课程",
                Cap:  0,
            },
            wantErr: true,
        },
    }
    // ...
}
```

**测试场景**:
| 场景 | 输入 | 期望结果 |
|------|------|----------|
| 有效请求 | cap=100 | false |
| 无效容量 | cap=0 | true |
| 负数容量 | cap=-1 | true |

---

#### TestMember_ToResponse - 成员响应转换

```go
func TestMember_ToResponse(t *testing.T) {
    member := &model.Member{
        UserID:    1,
        Username:  "testuser",
        Nickname:  "Test User",
        UserType:  model.UserTypeStudent,
        IsDeleted: false,
    }

    response := member.ToResponse()

    if response.UserID != "1" {
        t.Errorf("UserID = %s, want 1", response.UserID)
    }
}
```

---

#### TestErrCode_Error - 错误码测试

```go
func TestErrCode_Error(t *testing.T) {
    tests := []struct {
        name string
        code errcode.ErrCode
        want string
    }{
        {
            name: "成功",
            code: errcode.OK,
            want: "success",
        },
        {
            name: "参数错误",
            code: errcode.ParamInvalid,
            want: "参数不合法",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := tt.code.Error(); got != tt.want {
                t.Errorf("Error() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

---

### 4.2 排课算法测试 (scheduling_test.go)

#### TestScheduleService_Schedule - 排课算法测试

```go
func TestScheduleService_Schedule(t *testing.T) {
    svc := &service.ScheduleService{}

    tests := []struct {
        name    string
        prefs   map[string][]string
        wantErr bool
        validate func(result map[string]string) bool
    }{
        {
            name: "基础测试 - 正常匹配",
            prefs: map[string][]string{
                "a": {"1", "4"},
                "b": {"1", "2"},
                "c": {"2"},
                "d": {"3"},
            },
            wantErr: false,
            validate: func(result map[string]string) bool {
                // 验证每个教师都分配到了他们首选列表中的课程
                // 验证没有课程被分配给多个教师
                // ...
                return true
            },
        },
    }
    // ...
}
```

**测试场景**:
| 场景 | 教师偏好 | 期望结果 |
|------|----------|----------|
| 正常匹配 | a→{1,4}, b→{1,2}, c→{2}, d→{3} | 每个教师匹配到课程 |
| 单教师单课程 | teacher1→{course1} | teacher1 → course1 |
| 教师多于课程 | a→{1}, b→{1}, c→{1} | 只有一人匹配到课程 |
| 课程多于教师 | a→{1} | a → 1 |
| 空偏好 | {} | 返回空结果 |

---

#### TestScheduleService_ValidateSchedule - 排课结果验证

```go
func TestScheduleService_ValidateSchedule(t *testing.T) {
    svc := &service.ScheduleService{}

    tests := []struct {
        name       string
        assignments map[string]string
        want       bool
    }{
        {
            name: "有效分配",
            assignments: map[string]string{
                "a": "1",
                "b": "2",
            },
            want: true,
        },
        {
            name: "无效分配 - 课程分配给多个教师",
            assignments: map[string]string{
                "a": "1",
                "b": "1",
            },
            want: false,
        },
    }
    // ...
}
```

---

## 5. 负载测试

### 5.1 负载测试文件 (load_test.go)

```go
package load_test

import (
    "net/http"
    "sync"
    "testing"
)

func TestLoadCourseBooking(t *testing.T) {
    // 并发用户数
    concurrency := 100
    // 每个用户请求数
    requestsPerUser := 10

    var wg sync.WaitGroup
    for i := 0; i < concurrency; i++ {
        wg.Add(1)
        go func(userID int) {
            defer wg.Done()
            for j := 0; j < requestsPerUser; j++ {
                // 发送选课请求
                resp, err := http.Post(
                    "http://localhost:8080/api/v1/student/book_course",
                    "application/json",
                    strings.NewReader(`{"student_id":"`+strconv.Itoa(userID)+`","course_id":"1"}`),
                )
                if err != nil {
                    t.Logf("Request failed: %v", err)
                    continue
                }
                resp.Body.Close()
            }
        }(i)
    }
    wg.Wait()
}
```

### 5.2 运行负载测试

```bash
# 运行负载测试
go test ./test/load/... -v -timeout 5m
```

---

## 6. 测试最佳实践

### 6.1 测试用例命名

```go
// 推荐: 清晰的场景描述
func TestCreateMemberRequest_Validate_InvalidUserType(t *testing.T)

// 不推荐: 模糊的命名
func TestCreate1(t *testing.T)
```

### 6.2 使用表格驱动测试

```go
tests := []struct {
    name    string
    input   string
    want    string
}{
    {"case1", "input1", "expected1"},
    {"case2", "input2", "expected2"},
}

for _, tt := range tests {
    t.Run(tt.name, func(t *testing.T) {
        if got := myFunc(tt.input); got != tt.want {
            t.Errorf("myFunc(%s) = %s, want %s", tt.input, got, tt.want)
        }
    })
}
```

### 6.3 Mock 依赖

使用 Go mock 库隔离外部依赖：

```go
// 使用 mockery 生成 mock
//go:generate mockery -name=ICourseRepo

type MockCourseRepo struct {
    mock.Mock
}

func (m *MockCourseRepo) GetByID(ctx context.Context, id int) (*model.Course, error) {
    args := m.Called(ctx, id)
    return args.Get(0).(*model.Course), args.Error(1)
}
```

---

## 7. 持续集成

### 7.1 GitHub Actions 示例

```yaml
# .github/workflows/test.yml
name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'

      - name: Run tests
        run: |
          go test ./... -v -race -coverprofile=coverage.out

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.out
```

---

## 8. 测试数据

### 8.1 模拟用户数据

| user_type | username | password | 说明 |
|-----------|----------|----------|------|
| 1 | admin | admin123 | 管理员 |
| 2 | teacher01 | teacher123 | 教师 |
| 3 | student01 | student123 | 学生 |

### 8.2 模拟课程数据

| course_id | name | capacity | teacher_id |
|-----------|------|----------|------------|
| course_1 | 高等数学 | 100 | teacher_1 |
| course_2 | 大学物理 | 50 | teacher_2 |

---

## 9. 测试覆盖率

### 9.1 当前覆盖率

| 模块 | 覆盖率 |
|------|--------|
| domain/model | 85% |
| domain/service | 70% |
| application/service | 60% |

### 9.2 覆盖率目标

| 模块 | 目标覆盖率 |
|------|-----------|
| domain | 90% |
| application | 80% |
| interface | 70% |

---

## 10. 常见问题

### 10.1 测试失败排查

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 连接数据库失败 | 数据库未启动 | 启动 Docker Compose |
| Redis 连接失败 | Redis 配置错误 | 检查 config.yaml |
| 测试超时 | 资源竞争 | 增加 timeout 参数 |

### 10.2 运行测试命令

```bash
# 运行所有测试并显示覆盖率
go test ./... -coverprofile=coverage.out

# 运行指定包测试
go test ./internal/domain/... -v

# 运行包含race检测的测试
go test ./... -race

# 运行压力测试 (5分钟超时)
go test ./test/load/... -timeout 5m -v
```
